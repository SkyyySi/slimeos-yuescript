--- Turn globals into locals for performance
require  = require
print    = print
pcall    = pcall
os       = os
io       = io
table    = table
string   = string
tostring = tostring
tonumber = tonumber
rawget   = rawget
rawset   = rawset
getmetatable = getmetatable
setmetatable = setmetatable

--- Same as above, but for awesome built-ins
awesome = awesome
screen  = screen
client  = client
mouse   = mouse

--- Clear the console. Makes it cleaner for debugging.
os.execute("clear")

--- If LuaRocks is installed, make sure that packages installed through it are
--- found (e.g. lgi). If LuaRocks is not installed, do nothing.
pcall(require, "luarocks.loader")

--- Import awesome standard libraries
import "awful"
awful.hotkeys_popup = require("awful.hotkeys_popup")
import "gears"
import "wibox"
import "naughty"
import "beautiful"
import "menubar"

wibox.layout.overflow = require("overflow")

--- Enable hrtkeys help widget for VIM and other apps
--- when client with a matching name is opened:
require("awful.hotkeys_popup.keys")

--- {{{ Error handling
--- Check if awesome encountered an error during startup and fell back to
--- another config (This code will only ever execute for the fallback config)
naughty.connect_signal("request::display_error", (message, startup) -> naughty.notification {
	urgency: "critical"
	title:   "Oops, an error occured during " .. startup and "startup!" or "runtime!"
	message: message
})

do
	_error = error
	error = (msg, ...) ->
		naughty.emit_signal(msg)
		_error(msg, ...)
--- }}}

--- {{{ Auto reload
--[[
awful.spawn.with_line_callback([[bash -c '
inotifywait --event modify \
	--include '"'"'.*\.lua'"'"' \
	--recursive ./ \
	--monitor \
	--quiet \
	2> /dev/null
'] ], { stdout: (line) -> awesome.restart() })
--]]
--- }}}

--- {{{ App autostart
--- Picom, for transparency and other compositing effects.
--- Note: You should really be using the glx backend, which is OpenGL accelerated.
--- The reason xrender is used here is purely because Xephyr does not work
--- with glx at all, with the window just showing a "screenshot" of when picom
--- was started.
awful.spawn.once { "picom", "--backend=xrender", "--corner-radius=0" }
--- }}}

--- {{{ Variable definitions
--- Themes define colours, icons, font and wallpapers.
beautiful.init(gears.filesystem.get_configuration_dir() .. "themes/skyyysi/theme.lua")

slimeos = require("slimeos")
import util from slimeos.lib
import Enum from slimeos.lib.collection

logblock = (msg) ->
	with util.terminal
		print()
		.log.stroke()
		print()

		.log.block(msg, {
			shadow: true
			empty_shadow: false
			foreground: .color.foreground.normal.black
			background: .color.background.normal.blue
		})

		print()

logerror = (msg) ->
	with util.terminal
		.log.block("ERROR: #{msg}", {
			shadow: true
			empty_shadow: false
			foreground: .color.foreground.normal.black
			background: .color.background.normal.red
		})

		print()

try_or_log = (fn, ...) ->
	success, output = xpcall(fn, debug.traceback, ...)
	if not success
		--logerror(output)
		print(output)

with util.terminal
	.log.block("Welcome to SlimeOS!", {
		shadow: true
		empty_shadow: false
		foreground: .color.foreground.normal.black
		background: .color.background.normal.blue
	})

	print()
	.log.stroke()
	print()

--- This is used later as the default terminal and editor to run.
terminal = os.getenv("TERMINAL") ?? "xterm"
editor =   os.getenv("EDITOR")   ?? "#{terminal} -e nano"

cli_editors = Enum {
	"nano"
	"micro"
}

if cli_editors[editor]
	editor = "#{terminal} -e #{editor}"

menubar.utils.terminal = terminal

--- Default modkey.
--- Usually, Mod4 is the key with a logo between Control and Alt.
--- If you do not like this or do not have such a key,
--- I suggest you to remap Mod4 to another key using xmodmap or other tools.
--- However, you can use another modifier like Mod1, but it may interact with others.
modkey = "Mod1"

awful.spawn { "xrdb", "-merge", os.getenv("HOME") .. "/.Xresources" }

main_menu = slimeos.boxes.main_menu {
	terminal: terminal
}
--- }}}

--[[
do
	print()
	util.terminal.log.stroke()
	print()

	import List, Map, Tuple from require("slimeos.lib.collection")
	l, m, t = List({"foo", "bar", "biz", "baz"}), Map({ foo: "bar", biz: "baz"}), Tuple({"foo", "bar", "biz", "baz"})

	print("List  -> #{l}")
	print("Map   -> #{m}")
	print("Tuple -> #{t}")
--]]
--[[
	l[]   = "lua"
	m.yue = "lua"
	t[]   = "lua" -- Should crash!

	print("List  -> #{l}")
	print("Map   -> #{m}")
	print("Tuple -> #{t}")
--]]

--- {{{ Tag layout
--- Table of layouts to cover with awful.layout.inc, order matters.
tag.connect_signal("request::default_layouts", () -> awful.layout.append_default_layouts {
	awful.layout.suit.tile
	awful.layout.suit.floating
	--awful.layout.suit.floating
	--awful.layout.suit.tile
	--awful.layout.suit.tile.left
	--awful.layout.suit.tile.bottom
	--awful.layout.suit.tile.top
	--awful.layout.suit.fair
	--awful.layout.suit.fair.horizontal
	--awful.layout.suit.spiral
	--awful.layout.suit.spiral.dwindle
	--awful.layout.suit.max
	--awful.layout.suit.max.fullscreen
	--awful.layout.suit.magnifier
	--awful.layout.suit.corner.nw
})
--- }}}

awful.spawn.with_bash = (cmd) ->
	awful.spawn("bash -c '" .. cmd::gsub([[']], [['"'"']]) .. "'")

awful.spawn.with_bash_silently = (cmd) ->
	awful.spawn("bash -c '" .. cmd::gsub([[']], [['"'"']]) .. " &> /dev/null'")

--- {{{ Wallpaper
do
	run_silently = (cmd) ->
		awful.spawn.with_bash_silently(cmd)

	screen.connect_signal("request::wallpaper", (s) ->
		run_silently("nitrogen --restore")
	)
--- }}}

--- {{{ Wibar
screen.connect_signal("request::desktop_decoration", (s) ->
	slimeos.bars.main {
		screen:   s
		menu:     main_menu
		terminal: terminal
	}
)
--- }}}

require("slimeos.settings.bindings") {
	menu:     main_menu
	modkey:   modkey
	terminal: terminal
}

require("slimeos.settings.rules")

--- Enable sloppy focus, so that focus follows mouse.
client.connect_signal("mouse::enter", (c) ->
	c::activate {
		context: "mouse_enter"
		raise:   false
	}
)

do
	cg = collectgarbage
	cg("setpause", 110)
	cg("setstepmul", 1000)
	gears.timer {
		timeout:   5
		autostart: true
		call_now:  true
		callback:  () ->
			cg("collect")
	}

--{{{ Experiments
--[[
with Button = slimeos.widgets.Button
	placement = () => awful.placement.left(@, { honor_workarea: true, margins: util.scale(10) })

	local wb
	try_or_log(() ->
		wb = wibox {
			ontop:     true
			visible:   true
			width:     util.scale(200)
			height:    util.scale(100)
			bg:        gears.color.transparent
			widget: {
				{
					{
						nil,
						{
							{
								image:  util.lookup_icon("system-restart-symbolic")
								halign: "center"
								valign: "center"
								forced_width:  util.scale(30)
								forced_height: util.scale(30)
								widget: wibox.widget.imagebox
							}
							{
								markup: "<b>Restart awesome</b>"
								halign: "center"
								valign: "center"
								widget: wibox.widget.textbox
							}
							spacing: util.scale(10)
							layout:  wibox.layout.fixed.horizontal
						}
						expand: "outside"
						layout: wibox.layout.align.horizontal
					}
					buttons: {
						awful.button({}, 1, nil, () -> awesome.restart())
					}
					widget: Button
					--widget: wibox.container.background
				}
				bg: beautiful.bg_normal
				fg: beautiful.fg_normal
				shape_border_color: beautiful.fg_normal
				shape_border_width: util.scale(2)
				widget: wibox.container.background
			}
		}

		placement(wb)
	)
--]]

--[[
with TagLayoutIndicator = slimeos.widgets.TagLayoutIndicator
	placement = () => awful.placement.centered(@, { honor_workarea: true })

	local wb
	try_or_log(() ->
		wb = wibox {
			ontop:     true
			visible:   true
			width:     util.scale(100)
			height:    util.scale(100)
			bg:        gears.color.transparent
			widget: {
				{
					--awful.widget.layoutbox
					id:     "foobar"
					widget: TagLayoutIndicator
				}
				bg: beautiful.bg_normal
				fg: beautiful.fg_normal
				shape_border_color: beautiful.fg_normal
				shape_border_width: util.scale(2)
				widget: wibox.container.background
			}
		}

		placement(wb)
	)
--]]

--[[
with util.terminal
	.log.matrix2({
		{ { "left", "foo" }, { "right", "bar" } }
		{ { "left", "biz" }, { "right", "baz" } }
		{ { "left", "lua" }, { "center", "moon" }, { "right", "yue" } }
		{ { "center", "centered" }, { "right", "shorter line\nloooooooooooooooooooooooonger line" } }
		{ { "left", "loooooooooooooooooooooooooooooooooooooooooooooooooooooooong" }, { "center", "I'm centered" } }
		{ { "left", "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz" }, { "left", "I'm left and very loooooooooooooooooooooooooooooooooooong" } }
	}, {
		shadow: false
		empty_shadow: false
		foreground: .color.foreground.normal.black
		background: .color.background.normal.blue
		--columns: 2
		--rows: 3
	})
--]]

--[[
do
	--- A song lyrics widget. Requires https://github.com/Jugran/lyrics-in-terminal
	--- in addion to playerctl.

	lyrics_box_textbox = wibox.widget {
		valign: "top"
		widget: wibox.widget.textbox
	}

	lyrics_box = wibox {
		width:  util.scale(400)
		height: util.scale(700)
		--below = true
		ontop: true
		visible: true
		widget: {
			{
				lyrics_box_textbox
				layout: wibox.layout.overflow.vertical
			},
			margins: util.scale(10)
			widget:  wibox.container.margin
		}
	}

	awful.placement.right(lyrics_box, {
		honor_workarea: true
		margins: util.scale(20)
	})

	---@type PlayerctlMetadata
	local previous_metadata

	awesome.connect_signal("playerctl::metadata", (metadata) ->
		---@cast metadata PlayerctlMetadata

		if metadata::same_song_as(previous_metadata)
			return

		--notify(metadata, 0)

		awful.spawn.easy_async({ "lyrics", "-t", metadata.artist, metadata.title }, (stdout, stderr, reason, exit_code) ->
			lyrics_box_textbox.text = stdout or ""
		)

		previous_metadata = metadata
	)
--]]

do
	import "slimeos.widgets.SystemCenter"

	screen.connect_signal("request::desktop_decoration", (s) ->
		s.system_center = SystemCenter {
			screen: s
		}
	)

--[[
do
	import ClassPlus from require("slimeos.lib")

	wrap_gears_object = (gears_object, name="gears.object", ...) ->
		go = gears_object(...)

		local GearsObject
		GearsObject = ClassPlus
			name: name

			new: (cls, ...) ->
				@ = gears.table.crush({}, go)

				@.<> = cls.__body

				@

		for k, v in pairs(go)
			if rawget(GearsObject.__body, k) == nil
				rawset(GearsObject.__body, k, v)

		GearsObject

	local Background
	Background = ClassPlus
		name: "Background"

		parents: { wrap_gears_object(wibox.container.background, "wibox.container.background") }

	local GradientBackground
	GradientBackground = ClassPlus
		name: "GradientBackground"

		parents: { Background }

		body:
			set_bg: (color, ...) =>
				local super = () -> ClassPlus.super(GradientBackground)

				if type(color) != "string"
					return super().set_bg(@, color, ...)

				c = gears.color {
					type:  "linear"
					from:  { 0, 0 }
					to:    { util.scale(80), util.scale(80) }
					stops: { { 0, color }, { 1, "#5000D0" } }
				}

				print(" >>> Using gradient instead of normal color ('#{color}') <<<")
				print(" >>> #{super().set_bg} <<<")
				super().set_bg(@, c, ...)

	wb = wibox {
		width:   util.scale(80)
		height:  util.scale(80)
		visible: true
		ontop:   true
	}

	awful.placement.top_left(wb, { honor_workarea: true, margins: util.scale(10) })

	wb.widget = wibox.widget {
		bg:     "#FF0000" --- Works :)
		widget: GradientBackground
	}

	--wb.widget::set_bg("#0000FF") --- Doesn't work :(
	--wb.widget.bg = "#00FF00" --- Doesn't work :(
--]]
--}}}
